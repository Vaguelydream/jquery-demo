import { Kind, load } from 'yaml-ast-parser';
import isUndefined from 'lodash.isundefined';
import isNull from 'lodash.isnull';
import hasOwnProp from 'has-own-prop';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};





var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();













var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};









var newArrowCheck = function (innerThis, boundThis) {
  if (innerThis !== boundThis) {
    throw new TypeError("Cannot instantiate an arrow function");
  }
};

var _this = undefined;

var loc = Symbol('pseudo-yaml-ast-loc');

var isPrimitive = function (v) {
  newArrowCheck(this, _this);
  return Number.isNaN(v) || isNull(v) || isUndefined(v) || (typeof v === 'undefined' ? 'undefined' : _typeof(v)) === 'symbol';
}.bind(undefined);

var isPrimitiveNode = function (node) {
  newArrowCheck(this, _this);
  return isPrimitive(node.value) || !hasOwnProp(node, 'value');
}.bind(undefined);

var getLoc = function (input, _ref) {
  var _ref$start = _ref.start,
      start = _ref$start === undefined ? 0 : _ref$start,
      _ref$end = _ref.end,
      end = _ref$end === undefined ? 0 : _ref$end;
  newArrowCheck(this, _this);

  var lines = input.split(/\n/);

  var loc = {
    start: {},
    end: {}
  };

  var isBetween = function (start, pos, end) {
    newArrowCheck(this, _this);
    return pos <= end && pos >= start;
  }.bind(this);

  var sum = 0;

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = lines.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var i = _step.value;

      var line = lines[i];
      var ls = sum;
      var le = sum + line.length + 1; // +1 because the break is also a char

      if (isUndefined(loc.start.line) && isBetween(ls, start, le)) {
        loc.start.line = i + 1;
        loc.start.column = start - ls;
      }

      if (isUndefined(loc.end.line) && isBetween(ls, end, le)) {
        loc.end.line = i + 1;
        loc.end.column = end - ls;
      }

      sum = le;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return loc;
}.bind(undefined);

var visitors = {
  MAP: function MAP() {
    var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var input = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    newArrowCheck(this, _this);
    return Object.assign(walk(node.mappings, input), defineProperty({}, loc, getLoc(input, {
      start: node.startPosition,
      end: node.endPosition
    })));
  }.bind(undefined),
  MAPPING: function MAPPING() {
    var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var input = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var ctx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    newArrowCheck(this, _this);

    var value = walk([node.value], input);

    if (!isPrimitive(value)) {
      value[loc] = getLoc(input, {
        start: node.startPosition,
        end: node.endPosition
      });
    }

    return Object.assign(ctx, defineProperty({}, node.key.value, value));
  }.bind(undefined),
  SCALAR: function SCALAR() {
    var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var input = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    newArrowCheck(this, _this);

    if (isPrimitiveNode(node)) {
      return node.value;
    }

    var _loc = getLoc(input, {
      start: node.startPosition,
      end: node.endPosition
    });

    var wrappable = function (Constructor) {
      newArrowCheck(this, _this);
      return function () {
        newArrowCheck(this, _this);

        var v = new Constructor(node.value);
        v[loc] = _loc;
        return v;
      }.bind(this);
    }.bind(this);

    var object = function () {
      newArrowCheck(this, _this);

      node.value[loc] = _loc;
      return node.value;
    }.bind(this);

    var types = {
      boolean: wrappable(Boolean),
      number: wrappable(Number),
      string: wrappable(String),
      function: object,
      object: object
    };

    return types[_typeof(node.value)]();
  }.bind(undefined),
  SEQ: function SEQ() {
    var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var input = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    newArrowCheck(this, _this);

    var items = walk(node.items, input, []);

    items[loc] = getLoc(input, {
      start: node.startPosition,
      end: node.endPosition
    });

    return items;
  }.bind(undefined)
};

var walk = function () {
  var nodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var input = arguments[1];
  var ctx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  newArrowCheck(this, _this);

  var onNode = function (node, ctx, fallback) {
    newArrowCheck(this, _this);

    var visitor = visitors[Kind[node.kind]];
    return visitor ? visitor(node, input, ctx) : fallback;
  }.bind(this);

  var walkObj = function () {
    newArrowCheck(this, _this);
    return nodes.reduce(function (sum, node) {
      newArrowCheck(this, _this);

      return onNode(node, sum, sum);
    }.bind(this), ctx);
  }.bind(this);

  var walkArr = function () {
    newArrowCheck(this, _this);
    return nodes.map(function (node) {
      newArrowCheck(this, _this);
      return onNode(node, ctx, null);
    }.bind(this), ctx).filter(Boolean);
  }.bind(this);

  return Array.isArray(ctx) ? walkArr() : walkObj();
}.bind(undefined);

var index = (function (input) {
  newArrowCheck(this, _this);
  return walk([load(input)], input);
}).bind(undefined);

export { loc };
export default index;

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjpudWxsLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYW1pdG9zL2Rldi95bGQvcHNldWRvLXlhbWwtYXN0L3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBsb2FkLCBLaW5kIH0gZnJvbSAneWFtbC1hc3QtcGFyc2VyJztcbmltcG9ydCBpc1VuZGVmaW5lZCBmcm9tICdsb2Rhc2guaXN1bmRlZmluZWQnO1xuaW1wb3J0IGlzTnVsbCBmcm9tICdsb2Rhc2guaXNudWxsJztcbmltcG9ydCBoYXNPd25Qcm9wIGZyb20gJ2hhcy1vd24tcHJvcCc7XG5cbmV4cG9ydCBjb25zdCBsb2MgPSBTeW1ib2woJ3BzZXVkby15YW1sLWFzdC1sb2MnKTtcblxuY29uc3QgaXNQcmltaXRpdmUgPSB2ID0+XG4gIE51bWJlci5pc05hTih2KSB8fCBpc051bGwodikgfHwgaXNVbmRlZmluZWQodikgfHwgdHlwZW9mIHYgPT09ICdzeW1ib2wnO1xuXG5jb25zdCBpc1ByaW1pdGl2ZU5vZGUgPSBub2RlID0+XG4gIGlzUHJpbWl0aXZlKG5vZGUudmFsdWUpIHx8ICFoYXNPd25Qcm9wKG5vZGUsICd2YWx1ZScpO1xuXG5jb25zdCBnZXRMb2MgPSAoaW5wdXQsIHsgc3RhcnQgPSAwLCBlbmQgPSAwIH0pID0+IHtcbiAgY29uc3QgbGluZXMgPSBpbnB1dC5zcGxpdCgvXFxuLyk7XG5cbiAgY29uc3QgbG9jID0ge1xuICAgIHN0YXJ0OiB7fSxcbiAgICBlbmQ6IHt9XG4gIH07XG5cbiAgY29uc3QgaXNCZXR3ZWVuID0gKHN0YXJ0LCBwb3MsIGVuZCkgPT4gcG9zIDw9IGVuZCAmJiBwb3MgPj0gc3RhcnQ7XG5cbiAgbGV0IHN1bSA9IDA7XG5cbiAgZm9yIChjb25zdCBpIG9mIGxpbmVzLmtleXMoKSkge1xuICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICBjb25zdCBscyA9IHN1bTtcbiAgICBjb25zdCBsZSA9IHN1bSArIGxpbmUubGVuZ3RoICsgMTsgLy8gKzEgYmVjYXVzZSB0aGUgYnJlYWsgaXMgYWxzbyBhIGNoYXJcblxuICAgIGlmIChpc1VuZGVmaW5lZChsb2Muc3RhcnQubGluZSkgJiYgaXNCZXR3ZWVuKGxzLCBzdGFydCwgbGUpKSB7XG4gICAgICBsb2Muc3RhcnQubGluZSA9IGkgKyAxO1xuICAgICAgbG9jLnN0YXJ0LmNvbHVtbiA9IHN0YXJ0IC0gbHM7XG4gICAgfVxuXG4gICAgaWYgKGlzVW5kZWZpbmVkKGxvYy5lbmQubGluZSkgJiYgaXNCZXR3ZWVuKGxzLCBlbmQsIGxlKSkge1xuICAgICAgbG9jLmVuZC5saW5lID0gaSArIDE7XG4gICAgICBsb2MuZW5kLmNvbHVtbiA9IGVuZCAtIGxzO1xuICAgIH1cblxuICAgIHN1bSA9IGxlO1xuICB9XG5cbiAgcmV0dXJuIGxvYztcbn07XG5cbmNvbnN0IHZpc2l0b3JzID0ge1xuICBNQVA6IChub2RlID0ge30sIGlucHV0ID0gJycsIGN0eCA9IHt9KSA9PlxuICAgIE9iamVjdC5hc3NpZ24od2Fsayhub2RlLm1hcHBpbmdzLCBpbnB1dCksIHtcbiAgICAgIFtsb2NdOiBnZXRMb2MoaW5wdXQsIHtcbiAgICAgICAgc3RhcnQ6IG5vZGUuc3RhcnRQb3NpdGlvbixcbiAgICAgICAgZW5kOiBub2RlLmVuZFBvc2l0aW9uXG4gICAgICB9KVxuICAgIH0pLFxuICBNQVBQSU5HOiAobm9kZSA9IHt9LCBpbnB1dCA9ICcnLCBjdHggPSB7fSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gd2Fsayhbbm9kZS52YWx1ZV0sIGlucHV0KTtcblxuICAgIGlmICghaXNQcmltaXRpdmUodmFsdWUpKSB7XG4gICAgICB2YWx1ZVtsb2NdID0gZ2V0TG9jKGlucHV0LCB7XG4gICAgICAgIHN0YXJ0OiBub2RlLnN0YXJ0UG9zaXRpb24sXG4gICAgICAgIGVuZDogbm9kZS5lbmRQb3NpdGlvblxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oY3R4LCB7XG4gICAgICBbbm9kZS5rZXkudmFsdWVdOiB2YWx1ZVxuICAgIH0pO1xuICB9LFxuICBTQ0FMQVI6IChub2RlID0ge30sIGlucHV0ID0gJycpID0+IHtcbiAgICBpZiAoaXNQcmltaXRpdmVOb2RlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBfbG9jID0gZ2V0TG9jKGlucHV0LCB7XG4gICAgICBzdGFydDogbm9kZS5zdGFydFBvc2l0aW9uLFxuICAgICAgZW5kOiBub2RlLmVuZFBvc2l0aW9uXG4gICAgfSk7XG5cbiAgICBjb25zdCB3cmFwcGFibGUgPSBDb25zdHJ1Y3RvciA9PiAoKSA9PiB7XG4gICAgICBjb25zdCB2ID0gbmV3IENvbnN0cnVjdG9yKG5vZGUudmFsdWUpO1xuICAgICAgdltsb2NdID0gX2xvYztcbiAgICAgIHJldHVybiB2O1xuICAgIH07XG5cbiAgICBjb25zdCBvYmplY3QgPSAoKSA9PiB7XG4gICAgICBub2RlLnZhbHVlW2xvY10gPSBfbG9jO1xuICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gICAgfTtcblxuICAgIGNvbnN0IHR5cGVzID0ge1xuICAgICAgYm9vbGVhbjogd3JhcHBhYmxlKEJvb2xlYW4pLFxuICAgICAgbnVtYmVyOiB3cmFwcGFibGUoTnVtYmVyKSxcbiAgICAgIHN0cmluZzogd3JhcHBhYmxlKFN0cmluZyksXG4gICAgICBmdW5jdGlvbjogb2JqZWN0LFxuICAgICAgb2JqZWN0XG4gICAgfTtcblxuICAgIHJldHVybiB0eXBlc1t0eXBlb2Ygbm9kZS52YWx1ZV0oKTtcbiAgfSxcbiAgU0VROiAobm9kZSA9IHt9LCBpbnB1dCA9ICcnKSA9PiB7XG4gICAgY29uc3QgaXRlbXMgPSB3YWxrKG5vZGUuaXRlbXMsIGlucHV0LCBbXSk7XG5cbiAgICBpdGVtc1tsb2NdID0gZ2V0TG9jKGlucHV0LCB7XG4gICAgICBzdGFydDogbm9kZS5zdGFydFBvc2l0aW9uLFxuICAgICAgZW5kOiBub2RlLmVuZFBvc2l0aW9uXG4gICAgfSk7XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cbn07XG5cbmNvbnN0IHdhbGsgPSAobm9kZXMgPSBbXSwgaW5wdXQsIGN0eCA9IHt9KSA9PiB7XG4gIGNvbnN0IG9uTm9kZSA9IChub2RlLCBjdHgsIGZhbGxiYWNrKSA9PiB7XG4gICAgY29uc3QgdmlzaXRvciA9IHZpc2l0b3JzW0tpbmRbbm9kZS5raW5kXV07XG4gICAgcmV0dXJuIHZpc2l0b3IgPyB2aXNpdG9yKG5vZGUsIGlucHV0LCBjdHgpIDogZmFsbGJhY2s7XG4gIH07XG5cbiAgY29uc3Qgd2Fsa09iaiA9ICgpID0+XG4gICAgbm9kZXMucmVkdWNlKChzdW0sIG5vZGUpID0+IHtcbiAgICAgIHJldHVybiBvbk5vZGUobm9kZSwgc3VtLCBzdW0pO1xuICAgIH0sIGN0eCk7XG5cbiAgY29uc3Qgd2Fsa0FyciA9ICgpID0+XG4gICAgbm9kZXMubWFwKG5vZGUgPT4gb25Ob2RlKG5vZGUsIGN0eCwgbnVsbCksIGN0eCkuZmlsdGVyKEJvb2xlYW4pO1xuXG4gIHJldHVybiBBcnJheS5pc0FycmF5KGN0eCkgPyB3YWxrQXJyKCkgOiB3YWxrT2JqKCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBpbnB1dCA9PiB3YWxrKFtsb2FkKGlucHV0KV0sIGlucHV0KTtcbiJdLCJuYW1lcyI6WyJsb2MiLCJTeW1ib2wiLCJpc1ByaW1pdGl2ZSIsIk51bWJlciIsImlzTmFOIiwidiIsImlzTnVsbCIsImlzVW5kZWZpbmVkIiwiaXNQcmltaXRpdmVOb2RlIiwibm9kZSIsInZhbHVlIiwiaGFzT3duUHJvcCIsImdldExvYyIsImlucHV0Iiwic3RhcnQiLCJlbmQiLCJsaW5lcyIsInNwbGl0IiwiaXNCZXR3ZWVuIiwicG9zIiwic3VtIiwia2V5cyIsImkiLCJsaW5lIiwibHMiLCJsZSIsImxlbmd0aCIsImNvbHVtbiIsInZpc2l0b3JzIiwiT2JqZWN0IiwiYXNzaWduIiwid2FsayIsIm1hcHBpbmdzIiwic3RhcnRQb3NpdGlvbiIsImVuZFBvc2l0aW9uIiwiY3R4Iiwia2V5IiwiX2xvYyIsIndyYXBwYWJsZSIsIkNvbnN0cnVjdG9yIiwib2JqZWN0IiwidHlwZXMiLCJCb29sZWFuIiwiU3RyaW5nIiwiaXRlbXMiLCJub2RlcyIsIm9uTm9kZSIsImZhbGxiYWNrIiwidmlzaXRvciIsIktpbmQiLCJraW5kIiwid2Fsa09iaiIsInJlZHVjZSIsIndhbGtBcnIiLCJtYXAiLCJmaWx0ZXIiLCJBcnJheSIsImlzQXJyYXkiLCJsb2FkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxBQUtPLElBQU1BLE1BQU1DLE9BQU8scUJBQVAsQ0FBWjs7QUFFUCxJQUFNQyxjQUFjOztTQUNsQkMsT0FBT0MsS0FBUCxDQUFhQyxDQUFiLEtBQW1CQyxPQUFPRCxDQUFQLENBQW5CLElBQWdDRSxZQUFZRixDQUFaLENBQWhDLElBQWtELFFBQU9BLENBQVAseUNBQU9BLENBQVAsT0FBYSxRQUQ3QztDQUFkLGdCQUFOOztBQUdBLElBQU1HLGtCQUFrQjs7U0FDdEJOLFlBQVlPLEtBQUtDLEtBQWpCLEtBQTJCLENBQUNDLFdBQVdGLElBQVgsRUFBaUIsT0FBakIsQ0FETjtDQUFsQixnQkFBTjs7QUFHQSxJQUFNRyxTQUFTLFVBQUNDLEtBQUQsUUFBbUM7d0JBQXpCQyxLQUF5QjtNQUF6QkEsS0FBeUIsOEJBQWpCLENBQWlCO3NCQUFkQyxHQUFjO01BQWRBLEdBQWMsNEJBQVIsQ0FBUTs7O01BQzFDQyxRQUFRSCxNQUFNSSxLQUFOLENBQVksSUFBWixDQUFkOztNQUVNakIsTUFBTTtXQUNILEVBREc7U0FFTDtHQUZQOztNQUtNa0IsWUFBWSxVQUFDSixLQUFELEVBQVFLLEdBQVIsRUFBYUosR0FBYjs7V0FBcUJJLE9BQU9KLEdBQVAs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