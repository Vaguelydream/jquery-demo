"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.enhanceWithLitvisNarrativeSchemas = void 0;
const lodash_1 = __importDefault(require("lodash"));
const narrative_schema_label_1 = require("narrative-schema-label");
const narrative_schema_styling_1 = require("narrative-schema-styling");
const unist_util_select_1 = require("unist-util-select");
const markLabelAsErroneous = ($el, message) => {
    $el.children().attr("style", "background: #fdd");
    $el.attr("title", message);
};
exports.enhanceWithLitvisNarrativeSchemas = ($, processedNarrative, cache) => __awaiter(void 0, void 0, void 0, function* () {
    // add styling from narrative schema
    const arrayOf$StyleTags = [];
    if (processedNarrative.composedNarrativeSchema) {
        arrayOf$StyleTags.push(...narrative_schema_styling_1.getCssChunks(processedNarrative.composedNarrativeSchema).map((cssChunk) => {
            const $tag = $("<style />");
            $tag.text(`\n/* narrative schema: ${cssChunk.comment} */\n${cssChunk.content}`);
            return $tag;
        }));
    }
    if (arrayOf$StyleTags.length) {
        $("head").prepend("", ...arrayOf$StyleTags);
    }
    const labelNodesInAst = unist_util_select_1.selectAll("narrativeSchemaLabel", processedNarrative.combinedAst || { type: "", children: [] });
    const labelNodeInAstById = lodash_1.default.keyBy(labelNodesInAst, (node) => `${node.data.id}`);
    const labelIdPrefix = narrative_schema_label_1.getLabelIdPrefix(processedNarrative.documents[processedNarrative.documents.length - 1]);
    let labelIdIndex = 0;
    $('[data-role="litvis:narrative-schema-label"]').each((i, el) => {
        const labelId = `${labelIdPrefix}-${labelIdIndex}`;
        labelIdIndex += 1;
        const $el = $(el);
        const labelNodeInAst = labelNodeInAstById[labelId];
        if (!labelNodeInAst) {
            markLabelAsErroneous($el, "This label was not detected correctly by litivs-integration-mume. Please report a bug at https://github.com/gicentre/litvis.");
            return;
        }
        if (labelNodeInAst.data.errorType) {
            markLabelAsErroneous($el, labelNodeInAst.data.errorCaption || "Syntax error");
            return;
        }
        $el.replaceWith($("<litvis-narrative-schema-label/>").text(labelNodeInAst.data.html || ""));
    });
});
//# sourceMappingURL=enhanceWithLitvisNarrativeSchemas.js.map