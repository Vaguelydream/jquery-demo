"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractDefinitions = void 0;
const data_with_position_1 = require("data-with-position");
const lodash_1 = __importDefault(require("lodash"));
const narrative_schema_common_1 = require("narrative-schema-common");
const narrative_schema_label_1 = require("narrative-schema-label");
const selectorShape = {
    label: true,
    kind: true,
    trimmedContent: true,
};
const extractSelectorData = (narrativeSchema, selectorWithPosition, containerWithPosition, dataPath, selectorIsOptional = false) => {
    const dataToReturn = {};
    let selectorIsBroken = false;
    const kindOfSelector = data_with_position_1.getKind(selectorWithPosition);
    if (kindOfSelector === "undefined" || kindOfSelector === "null") {
        if (!selectorIsOptional) {
            narrativeSchema.message(`Expected rule ${narrative_schema_common_1.stringifyDataPath(dataPath)} to be an object, got ${kindOfSelector}`, data_with_position_1.getPosition(selectorWithPosition || containerWithPosition), "narrative-schema:rule");
            selectorIsBroken = true;
        }
    }
    else if (kindOfSelector !== "object") {
        narrativeSchema.message(`Expected rule selector to be an object, got ${kindOfSelector}`, data_with_position_1.getPosition(selectorWithPosition), "narrative-schema:rule");
        selectorIsBroken = true;
    }
    else {
        // selector.label
        const kindOfLabel = data_with_position_1.getKind(selectorWithPosition.label);
        const label = data_with_position_1.getValue(selectorWithPosition.label);
        if (kindOfLabel !== "string") {
            narrativeSchema.message(`Expected rule selector.label to be a string, got ${kindOfLabel}`, data_with_position_1.getPosition(selectorWithPosition.label || selectorWithPosition), "narrative-schema:rule");
            selectorIsBroken = true;
        }
        else if (!narrative_schema_label_1.isValidLabelName(label)) {
            narrativeSchema.message(`Expected label name to have a form of an identifier (i.e. to consist of latin characters, numbers or _)`, data_with_position_1.getPosition(selectorWithPosition.label), "narrative-schema:rule");
            selectorIsBroken = true;
        }
        else {
            dataToReturn.label = label;
        }
        // selector.kind
        const kindOfKind = data_with_position_1.getKind(selectorWithPosition.kind);
        const kind = data_with_position_1.getValue(selectorWithPosition.kind);
        if (kindOfKind === "null" || kindOfKind === "undefined") {
            // do nothing, because selector.kind is optional
        }
        else if (kind !== "single" && kind !== "paired") {
            narrativeSchema.message(`Expected rule selector.kind to be "single" or "paired", got ${kindOfKind === "string" ? kind : kindOfKind}`, data_with_position_1.getPosition(selectorWithPosition.kind || selectorWithPosition), "narrative-schema:rule");
            selectorIsBroken = true;
        }
        else {
            dataToReturn.label = label;
        }
        // selector trimmedContent
        const kindOfTrimmedContent = data_with_position_1.getKind(selectorWithPosition.trimmedContent);
        if (kindOfTrimmedContent === "null" ||
            kindOfTrimmedContent === "undefined") {
            //
        }
        else if (kindOfTrimmedContent !== "string") {
            narrativeSchema.message(`Expected rule ${narrative_schema_common_1.stringifyDataPath([
                ...dataPath,
                "trimmedContent",
            ])} to be a string, got ${kindOfTrimmedContent}`, data_with_position_1.getPosition(selectorWithPosition.trimmedContent), "narrative-schema:rule");
            selectorIsBroken = true;
        }
        else {
            dataToReturn.trimmedContent = data_with_position_1.getValue(selectorWithPosition.trimmedContent);
        }
    }
    if (selectorIsBroken) {
        throw new Error("data is broken");
    }
    return dataToReturn;
};
const extractDataFromRule = (narrativeSchema, ruleDataWithPosition, ruleDataPath) => {
    const ruleData = {};
    let ruleIsBroken = false;
    // ensure description
    const descriptionWithPosition = ruleDataWithPosition.description;
    const kindOfDescription = data_with_position_1.getKind(descriptionWithPosition);
    if (kindOfDescription !== "string") {
        ruleIsBroken = true;
        narrativeSchema.message(`Expected rule description to be a string, got ${kindOfDescription}`, data_with_position_1.getPosition(descriptionWithPosition || ruleDataWithPosition), "narrative-schema:rule");
    }
    else {
        const description = data_with_position_1.getValue(descriptionWithPosition);
        if (lodash_1.default.trim(description) === "") {
            narrativeSchema.message(`Expected rule description to be non-empty`, data_with_position_1.getPosition(descriptionWithPosition), "narrative-schema:rule");
            ruleIsBroken = true;
        }
        else {
            ruleData.description = description;
        }
    }
    // extract selector
    const selectorWithPosition = ruleDataWithPosition.selector;
    const kindOfSelector = data_with_position_1.getKind(selectorWithPosition);
    try {
        ruleData.selector = extractSelectorData(narrativeSchema, selectorWithPosition, ruleDataWithPosition, ["selector"]);
    }
    catch (e) {
        ruleIsBroken = true;
    }
    // occurrences
    ["minimumOccurrences", "maximumOccurrences"].forEach((occurrencesName) => {
        const kind = data_with_position_1.getKind(ruleDataWithPosition[occurrencesName]);
        if (kind === "null" || kind === "undefined") {
            return;
        }
        const value = data_with_position_1.getValue(ruleDataWithPosition[occurrencesName]);
        if (kind !== "number" || !Number.isInteger(value) || value < 0) {
            narrativeSchema.message(`Expected ${occurrencesName} to be a non-negative integer, got ${Number.isFinite(value) ? value : kind}`, data_with_position_1.getPosition(ruleDataWithPosition[occurrencesName]), "narrative-schema:rule");
            ruleIsBroken = true;
        }
        else {
            ruleData[occurrencesName] = value;
        }
    });
    if (Number.isInteger(ruleData.minimumOccurrences) &&
        Number.isInteger(ruleData.maximumOccurrences) &&
        ruleData.maximumOccurrences < ruleData.minimumOccurrences) {
        narrativeSchema.message(`The value for maximumOccurrences cannot be less than minimumOccurrences`, data_with_position_1.getPosition(ruleDataWithPosition.maximumOccurrences), "narrative-schema:rule");
        ruleIsBroken = true;
    }
    // children
    const kindOfChildren = data_with_position_1.getKind(ruleDataWithPosition.children);
    if (kindOfChildren === "null" || kindOfChildren === "undefined") {
        //
    }
    else if (kindOfSelector !== "object") {
        narrativeSchema.message(`Expected rule children to be an object, got ${kindOfChildren}`, data_with_position_1.getPosition(ruleDataWithPosition.children), "narrative-schema:rule");
        ruleIsBroken = true;
    }
    else {
        // minimumTrimmedTextLength
        const kind = data_with_position_1.getKind(ruleDataWithPosition.children.minimumTrimmedTextLength);
        const value = data_with_position_1.getValue(ruleDataWithPosition.children.minimumTrimmedTextLength);
        if (kind === "null" || kind === "undefined") {
            //
        }
        else if (kind !== "number" || !Number.isInteger(value) || value < 0) {
            narrativeSchema.message(`Expected children.minimumTrimmedTextLength to be a non-negative integer, got ${Number.isFinite(value) ? value : kind}`, data_with_position_1.getPosition(ruleDataWithPosition[ruleDataWithPosition.children.minimumTrimmedTextLength]), "narrative-schema:rule");
            ruleIsBroken = true;
        }
        else {
            ruleData.children = {
                minimumTrimmedTextLength: value,
            };
        }
    }
    // followedBy / notFollowedBy
    ["followedBy", "notFollowedBy", "before", "after"].forEach((property) => {
        const kind = data_with_position_1.getKind(ruleDataWithPosition[property]);
        if (kind === "null" || kind === "undefined") {
            //
        }
        else if (kind !== "object") {
            narrativeSchema.message(`Expected rule ${property} to be an object, got ${kind}`, data_with_position_1.getPosition(ruleDataWithPosition[property]), "narrative-schema:rule");
            ruleIsBroken = true;
        }
        else {
            try {
                ruleData[property] = {
                    selector: extractSelectorData(narrativeSchema, ruleDataWithPosition[property].selector, ruleDataWithPosition[property], [property, "selector"]),
                };
            }
            catch (e) {
                ruleIsBroken = true;
            }
            // if (property === "followedBy") {
            //   try {
            //     ruleData.selector = extractSelectorData(
            //       narrativeSchema,
            //       ruleDataWithPosition[property].notAfter,
            //       ruleDataWithPosition[property],
            //       [property, "notAfter"],
            //       true,
            //     );
            //   } catch (e) {
            //     ruleIsBroken = true;
            //   }
            // }
        }
    });
    // + selector,
    if (!ruleIsBroken && Object.keys(ruleData).length < 3) {
        narrativeSchema.message(`Rule ${lodash_1.default.last(ruleDataPath) * 1 + 1} does not defile any valid constrains`, data_with_position_1.getPosition(ruleDataWithPosition), "narrative-schema:rule");
        return null;
    }
    if (ruleIsBroken) {
        return null;
    }
    return ruleData;
};
exports.extractDefinitions = (dataWithPosition, narrativeSchema) => narrative_schema_common_1.extractArrayOfEntities(narrativeSchema, dataWithPosition, "rules", "rule", extractDataFromRule, {
    description: true,
    selector: selectorShape,
    minimumOccurrences: true,
    maximumOccurrences: true,
    children: {
        minimumTrimmedTextLength: true,
    },
    // immediate following
    followedBy: {
        selector: selectorShape,
    },
    notFollowedBy: {
        selector: selectorShape,
    },
    // following anywhere in the narrative
    before: {
        selector: selectorShape,
    },
    after: {
        selector: selectorShape,
    },
});
//# sourceMappingURL=extractDefinitions.js.map