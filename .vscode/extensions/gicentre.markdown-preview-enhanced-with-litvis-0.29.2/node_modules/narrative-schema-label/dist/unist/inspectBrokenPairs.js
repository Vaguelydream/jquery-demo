"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.inspectBrokenPairs = void 0;
const unist_util_visit_1 = __importDefault(require("unist-util-visit"));
const utils_1 = require("../utils");
exports.inspectBrokenPairs = () => (ast, vFile) => {
    return unist_util_visit_1.default(ast, "narrativeSchemaLabel", (labelNode, index, parent) => {
        if (labelNode.data.errorType ||
            (labelNode.data.labelType !== "paired_opening" &&
                labelNode.data.labelType !== "paired_closing")) {
            return;
        }
        if (!labelNode.data.pairedId) {
            const caption = `Could not find a matching ${labelNode.data.labelType === "paired_opening" ? "closing" : "opening"} label for ${labelNode.data.labelName}. ${labelNode.data.placement === "block"
                ? "This label is placed as block, so the match cannot be surrounded by inline elements and must be padded by empty lines."
                : "This label is inline, so the match must be located within the same paragraph and in the same inline element (if any)."}`;
            utils_1.markLabelNodeAsErroneous(vFile, labelNode, "brokenPair", caption);
        }
    });
};
//# sourceMappingURL=inspectBrokenPairs.js.map