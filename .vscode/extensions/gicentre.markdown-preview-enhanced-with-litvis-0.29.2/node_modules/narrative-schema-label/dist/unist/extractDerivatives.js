"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractDerivatives = void 0;
const block_info_1 = require("block-info");
const lodash_1 = __importDefault(require("lodash"));
const unist_util_visit_1 = __importDefault(require("unist-util-visit"));
const utils_1 = require("../utils");
exports.extractDerivatives = () => (ast, vFile) => {
    const idPrefix = utils_1.getLabelIdPrefix(vFile);
    let idIndex = 0;
    return unist_util_visit_1.default(ast, "narrativeSchemaLabel", (labelNode) => {
        const parsedInfo = block_info_1.parseBlockInfo(labelNode.data.info);
        const labelName = parsedInfo.language;
        const labelType = labelNode.data.labelType;
        const labelAttributes = parsedInfo.attributes;
        labelNode.labelName = labelName;
        labelNode.data.labelName = labelName;
        labelNode.data.labelAttributes = labelAttributes;
        // id helps litvis-integration-mume match labels in uniast
        // with the ones it finds in markdown-it tree
        labelNode.data.id = `${idPrefix}-${idIndex}`;
        idIndex += 1;
        if (!labelName) {
            utils_1.markLabelNodeAsErroneous(vFile, labelNode, "blank", `Label cannot be blank.`);
            return;
        }
        if (labelType === "invalid") {
            utils_1.markLabelNodeAsErroneous(vFile, labelNode, "invalid", `Label ${labelName} is neither single nor paired, please change the endings.`);
            return;
        }
        if (labelType === "paired_closing" && !lodash_1.default.isEmpty(labelAttributes)) {
            utils_1.markLabelNodeAsErroneous(vFile, labelNode, "closingWithAttributes", `A closing paired label cannot have attributes.`);
            return;
        }
    });
};
//# sourceMappingURL=extractDerivatives.js.map