"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findLabels = void 0;
const types_1 = require("../types");
const utils_1 = require("../utils");
const locator = (value, fromIndex) => {
    const indexOfStart = value.indexOf(types_1.LabelFence.START, fromIndex);
    const indexOfStartClosing = value.indexOf(types_1.LabelFence.START_CLOSING, fromIndex);
    if (indexOfStart > -1 && indexOfStartClosing > -1) {
        return Math.min(indexOfStart, indexOfStartClosing);
    }
    return Math.max(indexOfStart, indexOfStartClosing);
};
// Usage of "this" requires suppressing func-style eslint rule
// eslint-disable-next-line func-style
function findLabels() {
    // eslint-disable-next-line func-style
    function inlineTokenizer(eat, value, silent) {
        if (!value.startsWith(types_1.LabelFence.START) &&
            !value.startsWith(types_1.LabelFence.START_CLOSING)) {
            return;
        }
        const start = value.substring(0, 2);
        let character = "";
        let previous = "";
        let subvalue = "";
        let index = 1;
        const length = value.length;
        const now = eat.now();
        now.column += 1;
        now.offset += 1;
        while (++index < length) {
            character = value.charAt(index);
            const end = `${previous}${character}`;
            if (end === types_1.LabelFence.END || end === types_1.LabelFence.END_OPENING) {
                /* istanbul ignore if - never used (yet) */
                if (silent) {
                    return true;
                }
                return eat(start + subvalue + end)({
                    type: "narrativeSchemaLabel",
                    data: {
                        info: subvalue,
                        labelType: utils_1.deriveLabelType(start, end),
                    },
                });
            }
            subvalue += previous;
            previous = character;
        }
    }
    inlineTokenizer.locator = locator;
    const Parser = this.Parser;
    // Inject inlineTokenizer
    const inlineTokenizers = Parser.prototype.inlineTokenizers;
    const inlineMethods = Parser.prototype.inlineMethods;
    inlineTokenizers.narrativeSchemaLabel = inlineTokenizer;
    inlineMethods.splice(inlineMethods.indexOf("text"), 0, "narrativeSchemaLabel");
}
exports.findLabels = findLabels;
//# sourceMappingURL=findLabels.js.map