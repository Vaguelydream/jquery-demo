"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensureEnvironment = void 0;
const fs_extra_1 = require("fs-extra");
const object_hash_1 = __importDefault(require("object-hash"));
const path_1 = require("path");
const auxFiles_1 = require("./shared/auxFiles");
const gc_1 = require("./shared/gc");
const tools_1 = require("./shared/tools");
const CACHE_SHAPE_VERSION = "v1";
const CACHE_DIRECTORY_SALT = "v0.19";
const DEFAULT_TIMEOUT = 30000;
const PROJECT_EXPIRY_WITH_ERRORS = 1000 * 60;
const PROJECT_EXPIRY_WITH_NO_ELM_FOUND = 1000 * 5;
// const PROJECT_EXPIRY_WITH_LATEST = 1000 * 60 * 60 * 24 * 7;
const prepareElmApplication = (directory, dependencies, sourceDirectories) => __awaiter(void 0, void 0, void 0, function* () {
    // install dependencies
    yield tools_1.initializeElmProject(directory);
    let userRequestsJsonPackage = false;
    for (const packageName in dependencies) {
        if (dependencies.hasOwnProperty(packageName)) {
            const packageVersion = dependencies[packageName];
            yield tools_1.installElmPackage(directory, packageName, packageVersion);
            if (packageName === "elm/json") {
                userRequestsJsonPackage = true;
            }
        }
    }
    if (!userRequestsJsonPackage) {
        yield tools_1.installElmPackage(directory, "elm/json", "latest");
    }
    // add sourceDirectories to elm.json
    yield tools_1.patchElmJson(directory, (elmJson) => {
        elmJson["source-directories"] = [...sourceDirectories, "."];
    });
});
const resolvePathToMetadata = (workingDirectory) => {
    return path_1.resolve(workingDirectory, "literate-elm-metadata.json");
};
exports.ensureEnvironment = (spec, literateElmDirectory, timeout = DEFAULT_TIMEOUT) => __awaiter(void 0, void 0, void 0, function* () {
    const now = +new Date();
    const currentCacheDirectory = path_1.resolve(literateElmDirectory, CACHE_SHAPE_VERSION);
    try {
        yield auxFiles_1.ensureUnlocked(literateElmDirectory);
    }
    catch (e) {
        // resetting directory lock (garbage collector in another process could get stuck)
        auxFiles_1.unlock(literateElmDirectory);
    }
    yield gc_1.collectGarbageIfNeeded(literateElmDirectory);
    const specDirectory = path_1.resolve(currentCacheDirectory, `spec${object_hash_1.default({ spec, CACHE_DIRECTORY_SALT })}`);
    try {
        yield fs_extra_1.ensureDir(specDirectory);
        const specJsonPath = path_1.resolve(specDirectory, `spec.json`);
        if (!(yield fs_extra_1.pathExists(specJsonPath))) {
            yield fs_extra_1.writeFile(specJsonPath, JSON.stringify(spec, null, 4), "utf8");
        }
    }
    catch (e) {
        return {
            spec,
            workingDirectory: specDirectory,
            metadata: {
                createdAt: now,
                status: "error",
                errorMessage: `Could not create directory ${specDirectory}`,
            },
        };
    }
    // attempt to restore existing environment
    const currentWorkingDirectoryLocatorPath = path_1.resolve(specDirectory, "wd");
    try {
        yield auxFiles_1.ensureUnlocked(specDirectory, timeout);
        const workingSubdirectory = yield fs_extra_1.readFile(currentWorkingDirectoryLocatorPath, "utf8");
        const workingDirectory = path_1.resolve(specDirectory, workingSubdirectory);
        const metadata = JSON.parse(yield fs_extra_1.readFile(resolvePathToMetadata(workingDirectory), "utf8"));
        if (metadata.expiresAt && metadata.expiresAt < now) {
            throw new Error("Expired");
        }
        return {
            metadata,
            spec,
            workingDirectory,
        };
    }
    catch (e) {
        //
    }
    try {
        yield auxFiles_1.lock(specDirectory);
        const workingSubdirectory = `wd${now}`;
        const workingDirectory = path_1.resolve(specDirectory, workingSubdirectory);
        yield fs_extra_1.ensureDir(workingDirectory);
        let metadata;
        try {
            yield prepareElmApplication(workingDirectory, spec.dependencies, spec.sourceDirectories);
            metadata = {
                status: "ready",
                createdAt: now,
            };
        }
        catch (e) {
            yield auxFiles_1.touch(path_1.resolve(workingDirectory, "ProgramFORGC"));
            const isElmFound = `${e.message}`.indexOf("ENOENT") === -1 &&
                `${e.message}`.indexOf("No elm global binary available") === -1;
            metadata = {
                status: "error",
                createdAt: now,
                expiresAt: now +
                    (isElmFound
                        ? PROJECT_EXPIRY_WITH_ERRORS
                        : PROJECT_EXPIRY_WITH_NO_ELM_FOUND),
                errorMessage: isElmFound
                    ? e.message
                    : 'I am having trouble finding Elm on your machine. Is it installed? Check by opening a terminal window and typing "elm --version" (without quotation marks). If you have recently installed Elm, try restarting your machine.',
            };
        }
        yield fs_extra_1.writeFile(resolvePathToMetadata(workingDirectory), JSON.stringify(metadata, null, 2), "utf8");
        yield fs_extra_1.writeFile(currentWorkingDirectoryLocatorPath, workingSubdirectory, "utf8");
        return {
            spec,
            workingDirectory,
            metadata,
        };
    }
    catch (e) {
        return {
            spec,
            workingDirectory: specDirectory,
            metadata: {
                createdAt: now,
                status: "error",
                errorMessage: e.message,
            },
        };
    }
    finally {
        yield auxFiles_1.unlock(specDirectory);
    }
});
//# sourceMappingURL=ensureEnvironment.js.map