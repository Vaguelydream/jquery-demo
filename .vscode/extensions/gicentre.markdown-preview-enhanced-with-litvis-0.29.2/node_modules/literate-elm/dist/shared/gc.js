"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.collectGarbageIfNeeded = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const globby_1 = __importDefault(require("globby"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = require("path");
const auxFiles_1 = require("./auxFiles");
const GARBAGE_COLLECTION_INTERVAL = 1000 * 60 * 5;
const MAX_PROGRAM_COUNT = 500;
const MAX_PROGRAM_LIFETIME = 1000 * 60 * 60 * 24 * 10;
// const GARBAGE_COLLECTION_INTERVAL = 1000 * 5;
// const MAX_PROGRAM_COUNT = 20;
// const MAX_PROGRAM_LIFETIME = 1000 * 60;
exports.collectGarbageIfNeeded = (literateElmDirectory) => __awaiter(void 0, void 0, void 0, function* () {
    const gcFilePath = `${literateElmDirectory}/gc`;
    if (yield auxFiles_1.hasBeenTouchedWithin(gcFilePath, GARBAGE_COLLECTION_INTERVAL)) {
        return;
    }
    if (yield auxFiles_1.isLocked(literateElmDirectory)) {
        return;
    }
    yield fs_extra_1.default.ensureDir(literateElmDirectory);
    yield auxFiles_1.lock(literateElmDirectory);
    const programRelatedPaths = yield globby_1.default("*/*/*/Program*.*", {
        cwd: literateElmDirectory,
    });
    const groupedProgramRelatedPaths = lodash_1.default.groupBy(programRelatedPaths, (path) => path.replace(/\..*/, ""));
    const fileGroupInfos = lodash_1.default.map(groupedProgramRelatedPaths, (filePaths, relativeBasePath) => ({
        relativeSpecDirectory: relativeBasePath.substring(0, relativeBasePath.indexOf("wd") - 1),
        relativeWorkingDirectory: relativeBasePath.substring(0, relativeBasePath.indexOf("Program") - 1),
        relativeBasePath,
        filePaths,
        lastTouchedAt: 0,
    }));
    const touchedAtResolutionPromises = fileGroupInfos.map((fileGroupInfo) => (() => __awaiter(void 0, void 0, void 0, function* () {
        const lastTouchedAt = yield auxFiles_1.getLastTouchedAt(path_1.resolve(literateElmDirectory, fileGroupInfo.relativeBasePath));
        fileGroupInfo.lastTouchedAt = lastTouchedAt;
    }))());
    yield Promise.all(touchedAtResolutionPromises);
    const sortedFileGroupInfos = lodash_1.default.orderBy(fileGroupInfos, "lastTouchedAt", "desc");
    const programLifetimeThreshold = +new Date() - MAX_PROGRAM_LIFETIME;
    const fileGroupInfosToRemove = [];
    const fileGroupInfosToRetain = [];
    sortedFileGroupInfos.forEach((fileGroupInfo, index) => {
        if (index >= MAX_PROGRAM_COUNT ||
            fileGroupInfo.lastTouchedAt < programLifetimeThreshold) {
            fileGroupInfosToRemove.push(fileGroupInfo);
        }
        else {
            fileGroupInfosToRetain.push(fileGroupInfo);
        }
    });
    const relativeSpecDirectoriesToRetain = lodash_1.default.uniq(lodash_1.default.map(fileGroupInfosToRetain, "relativeSpecDirectory"));
    const relativeWorkingDirectoriesToRetain = lodash_1.default.uniq(lodash_1.default.map(fileGroupInfosToRetain, "relativeWorkingDirectory"));
    const removedRelativeSpecDirectories = [];
    const removedRelativeWorkingDirectories = [];
    const relativePathsToRemove = [];
    lodash_1.default.forEach(fileGroupInfosToRemove, ({ relativeSpecDirectory, relativeWorkingDirectory, filePaths }) => {
        if (!lodash_1.default.includes(relativeSpecDirectoriesToRetain, relativeSpecDirectory)) {
            if (!lodash_1.default.includes(removedRelativeSpecDirectories, relativeSpecDirectory)) {
                relativePathsToRemove.push(relativeSpecDirectory);
            }
            removedRelativeSpecDirectories.push(relativeSpecDirectory);
            return;
        }
        if (!lodash_1.default.includes(relativeWorkingDirectoriesToRetain, relativeWorkingDirectory)) {
            if (!lodash_1.default.includes(removedRelativeWorkingDirectories, relativeWorkingDirectory)) {
                relativePathsToRemove.push(relativeWorkingDirectory);
            }
            removedRelativeWorkingDirectories.push(relativeWorkingDirectory);
            return;
        }
        lodash_1.default.forEach(filePaths, (filePath) => relativePathsToRemove.push(filePath));
    });
    const removePromises = relativePathsToRemove.map((relativePath) => fs_extra_1.default.remove(path_1.resolve(literateElmDirectory, relativePath)));
    yield Promise.all(removePromises);
    yield auxFiles_1.touch(gcFilePath);
    yield auxFiles_1.unlock(literateElmDirectory);
});
//# sourceMappingURL=gc.js.map