"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.processElmContexts = void 0;
const literate_elm_1 = require("literate-elm");
const lodash_1 = __importDefault(require("lodash"));
const unist_util_visit_1 = __importDefault(require("unist-util-visit"));
const fallbackPosition = {
    start: { column: 0, line: 0 },
    end: { column: 0, line: 0 },
};
exports.processElmContexts = (narrative, cache) => __awaiter(void 0, void 0, void 0, function* () {
    // const documentPaths = _.map(narrative.documents, (document) => document.path);
    // const documentIndexByPath: { [path: string]: number } = _.mapValues(
    //   _.invert(documentPaths),
    //   (v) => parseInt(v, 10),
    // );
    const lastDocument = lodash_1.default.last(narrative.documents);
    const lastDocumentIndex = narrative.documents.length - 1;
    if (!lastDocument) {
        return;
    }
    const literateElmJobs = [];
    try {
        const wrappedCodeBlocksInAllDocuments = [];
        const wrappedCodeBlocksInLastDocument = [];
        lodash_1.default.forEach(narrative.documents, (document, documentIndex) => {
            unist_util_visit_1.default(document.data.root, "code", (codeBlock) => {
                if (codeBlock.data && codeBlock.data.litvisAttributeDerivatives) {
                    const wrappedCodeBlock = {
                        subject: codeBlock,
                        documentIndex,
                    };
                    wrappedCodeBlocksInAllDocuments.push(wrappedCodeBlock);
                    if (document === lastDocument) {
                        wrappedCodeBlocksInLastDocument.push(wrappedCodeBlock);
                    }
                }
            });
        });
        const wrappedOutputExpressionsInLastFile = [];
        unist_util_visit_1.default(lastDocument.data.root, "outputExpression", (outputExpression) => {
            wrappedOutputExpressionsInLastFile.push({
                subject: outputExpression,
                documentIndex: lastDocumentIndex,
            });
        });
        // build contexts by tracing down chains of code blocks
        const foundContextsByName = {};
        lodash_1.default.forEachRight(wrappedCodeBlocksInAllDocuments, (wrappedCodeBlock, index) => {
            const derivatives = wrappedCodeBlock.subject.data.litvisAttributeDerivatives;
            const contextName = derivatives.contextName;
            // skip if a code block belongs to a context that is already considered
            if (foundContextsByName[contextName]) {
                return;
            }
            // ignore contexts where last code blocks do not belong to the last document
            if (!lodash_1.default.includes(wrappedCodeBlocksInLastDocument, wrappedCodeBlock)) {
                return;
            }
            const context = {
                name: contextName,
                wrappedCodeBlocks: [],
                wrappedOutputExpressions: [],
            };
            foundContextsByName[contextName] = context;
            let currentIndex = index;
            let currentContextName = contextName;
            do {
                context.wrappedCodeBlocks.unshift(wrappedCodeBlocksInAllDocuments[currentIndex]);
                if (currentIndex === 0) {
                    break;
                }
                const follows = wrappedCodeBlocksInAllDocuments[currentIndex].subject.data
                    .litvisAttributeDerivatives.follows;
                if (follows) {
                    currentIndex = lodash_1.default.findLastIndex(wrappedCodeBlocksInAllDocuments, (b) => b.subject.data.litvisAttributeDerivatives.id === follows ||
                        b.subject.data.litvisAttributeDerivatives.contextName ===
                            follows, currentIndex - 1);
                    if (currentIndex !== -1) {
                        currentContextName =
                            wrappedCodeBlocksInAllDocuments[currentIndex].subject.data
                                .litvisAttributeDerivatives.contextName;
                    }
                }
                else {
                    currentIndex = lodash_1.default.findLastIndex(wrappedCodeBlocksInAllDocuments, (b) => b.subject.data.litvisAttributeDerivatives.contextName ===
                        currentContextName, currentIndex - 1);
                }
            } while (currentIndex >= 0);
        });
        // add output expressions to contexts
        lodash_1.default.forEach(wrappedOutputExpressionsInLastFile, (wrappedOutputExpression) => {
            const contextName = wrappedOutputExpression.subject.data.contextName;
            if (foundContextsByName[contextName]) {
                foundContextsByName[contextName].wrappedOutputExpressions.push(wrappedOutputExpression);
            }
            else {
                foundContextsByName[contextName] = {
                    name: contextName,
                    wrappedCodeBlocks: [],
                    wrappedOutputExpressions: [wrappedOutputExpression],
                };
            }
        });
        lodash_1.default.forEach(foundContextsByName, ({ wrappedCodeBlocks, wrappedOutputExpressions }, contextName) => {
            const codeNodes = lodash_1.default.map(wrappedCodeBlocks, (wrappedCodeBlock) => ({
                text: wrappedCodeBlock.subject.value,
                position: wrappedCodeBlock.subject.position || fallbackPosition,
                fileIndex: wrappedCodeBlock.documentIndex,
            }));
            const expressionNodes = lodash_1.default.map(wrappedOutputExpressions, (wrappedOutputExpression) => ({
                text: wrappedOutputExpression.subject.data.text,
                position: wrappedOutputExpression.subject.position || fallbackPosition,
                fileIndex: wrappedOutputExpression.documentIndex,
            }));
            literateElmJobs.push({
                contextName,
                codeNodes,
                expressionNodes,
            });
        });
        if (!literateElmJobs.length) {
            return;
        }
        const literateElmEnvironment = yield literate_elm_1.ensureEnvironment(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        narrative.elmEnvironmentSpecForLastFile, cache.literateElmDirectory);
        if (literateElmEnvironment.metadata.status !== "ready") {
            try {
                lastDocument.fail(literateElmEnvironment.metadata.errorMessage || "Unknown error", undefined, "litvis:elm-environment");
            }
            catch (e) {
                // no need for action - just preventing .fail() from throwing further
            }
            return;
        }
        const literateElmProgramPromises = literateElmJobs.map(({ codeNodes, expressionNodes }) => literate_elm_1.runProgram({
            environment: literateElmEnvironment,
            codeNodes,
            expressionNodes,
        }));
        const literateElmProgramResults = yield Promise.all(literateElmProgramPromises);
        // map literate-elm messages to vfile messages
        const allMessages = lodash_1.default.flatten(lodash_1.default.map(literateElmProgramResults, (result) => result.messages));
        const messagesGroupedByPositionAndText = lodash_1.default.groupBy(allMessages, (message) => `${JSON.stringify(message.position)}|${message.text}`);
        lodash_1.default.forEach(messagesGroupedByPositionAndText, (messageGroup) => {
            const message = messageGroup[0];
            const document = narrative.documents[message.fileIndex];
            switch (message.severity) {
                case "info": {
                    document.info(message.text, message.position, "literate-elm:compile");
                }
                case "warning": {
                    document.message(message.text, message.position, "literate-elm:compile");
                }
                default: {
                    try {
                        document.fail(message.text, message.position, "literate-elm:compile");
                    }
                    catch (e) {
                        // no need for action - just preventing .fail() from throwing further
                    }
                }
            }
        });
        const processedContexts = lodash_1.default.map(literateElmJobs, ({ contextName }, index) => {
            const literateElmProgramResult = literateElmProgramResults[index];
            const context = foundContextsByName[contextName];
            if (literateElmProgramResult.status === "failed") {
                const processedContext = {
                    name: contextName,
                    status: "failed",
                };
                return processedContext;
            }
            else {
                if (literateElmProgramResult.debugLog.length) {
                    lastDocument.info(`Debug.log results in context "${contextName}":\n${literateElmProgramResult.debugLog.join("\n")}`, undefined, "literate-elm:debug-log");
                }
                const evaluatedOutputExpressions = lodash_1.default.map(context.wrappedOutputExpressions, (wrappedOutputExpression, i) => {
                    const evaluatedExpressionInProgram = literateElmProgramResult.evaluatedExpressions[i];
                    const evaluatedExpression = wrappedOutputExpression.subject;
                    const document = narrative.documents[evaluatedExpressionInProgram.node.fileIndex || 0];
                    evaluatedExpression.data.value =
                        evaluatedExpressionInProgram.value;
                    evaluatedExpression.data.valueStringRepresentation =
                        evaluatedExpressionInProgram.valueStringRepresentation;
                    if (evaluatedExpression.data.outputFormat !== "r" &&
                        evaluatedExpression.data.value instanceof Error) {
                        document.message(evaluatedExpression.data.value.message, evaluatedExpression.position, "litvis:expression-value");
                    }
                    return evaluatedExpression;
                });
                const processedContext = {
                    name: contextName,
                    status: literateElmProgramResult.status,
                    evaluatedOutputExpressions,
                    debugLog: literateElmProgramResult.debugLog,
                };
                return processedContext;
            }
        });
        narrative.contexts = processedContexts;
    }
    catch (error) {
        try {
            lastDocument.fail(error.message);
        }
        catch (_a) {
            // no need for action - just preventing .fail() from throwing further
        }
    }
});
//# sourceMappingURL=processElmContexts.js.map