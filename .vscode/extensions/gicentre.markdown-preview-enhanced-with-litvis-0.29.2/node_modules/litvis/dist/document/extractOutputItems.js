"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractOutputItems = void 0;
const lodash_1 = __importDefault(require("lodash"));
const unist_util_visit_1 = __importDefault(require("unist-util-visit"));
const attributeDerivatives_1 = require("../attributeDerivatives");
const visitCodeBlock = (ast, vFile) => {
    return unist_util_visit_1.default(ast, "code", (codeBlockNode, index, parent) => {
        if (!codeBlockNode.data ||
            !codeBlockNode.data.litvisAttributeDerivatives) {
            return;
        }
        // do not re-visit the same code block twice
        if (codeBlockNode.data.visitedByExtractOutputItems) {
            return;
        }
        codeBlockNode.data.visitedByExtractOutputItems = true;
        const nodesBefore = [];
        const nodesAfter = [];
        let nodes = nodesBefore;
        const derivatives = attributeDerivatives_1.resolveExpressions(codeBlockNode.data.litvisAttributeDerivatives, codeBlockNode.value);
        derivatives.outputFormats.forEach((outputFormat) => {
            switch (outputFormat) {
                case "l":
                    nodes = nodesAfter;
                    break;
                default:
                    const expressions = derivatives.outputExpressionsByFormat[outputFormat] || [];
                    nodes.push(...expressions.map((expression) => ({
                        type: "outputExpression",
                        position: codeBlockNode.position,
                        value: expression,
                        data: {
                            text: expression,
                            outputFormat: outputFormat,
                            contextName: derivatives.contextName,
                        },
                    })));
            }
        });
        const resultingNodes = [];
        if (nodesBefore.length) {
            resultingNodes.push({
                type: "outputExpressionGroup",
                children: nodesBefore,
            });
        }
        resultingNodes.push(codeBlockNode);
        if (nodesAfter.length) {
            resultingNodes.push({
                type: "outputExpressionGroup",
                children: nodesAfter,
            });
        }
        parent.children.splice(index, 1, ...resultingNodes);
    });
};
const visitTripleHatReference = (ast, vFile) => {
    return unist_util_visit_1.default(ast, "tripleHatReference", (tripleHatReferenceNode) => {
        if (!tripleHatReferenceNode.data ||
            !tripleHatReferenceNode.data.litvisAttributeDerivatives) {
            return;
        }
        const nodes = [];
        const derivatives = tripleHatReferenceNode.data.litvisAttributeDerivatives;
        derivatives.outputFormats.forEach((outputFormat) => {
            switch (outputFormat) {
                case "l":
                    vFile.message("Use of l is not allowed in triple hat references.", tripleHatReferenceNode, "litvis:triple-hat-reference-use");
                    break;
                default:
                    const expressions = derivatives.outputExpressionsByFormat[outputFormat];
                    if (lodash_1.default.isArray(expressions)) {
                        nodes.push(...expressions.map((expression) => ({
                            type: "outputExpression",
                            position: tripleHatReferenceNode.position,
                            value: expression,
                            data: {
                                text: expression,
                                outputFormat: outputFormat,
                                contextName: derivatives.contextName,
                            },
                        })));
                    }
                    else {
                        vFile.message(`${outputFormat} should be followed by a list of expressions in triple hat references.`, tripleHatReferenceNode, "litvis:triple-hat-reference-use");
                    }
            }
            tripleHatReferenceNode.children = nodes;
        });
    });
};
exports.extractOutputItems = () => {
    return function transformer(ast, vFile, next) {
        visitCodeBlock(ast, vFile);
        visitTripleHatReference(ast, vFile);
        if (typeof next === "function") {
            return next(null, ast, vFile);
        }
        return ast;
    };
};
//# sourceMappingURL=extractOutputItems.js.map