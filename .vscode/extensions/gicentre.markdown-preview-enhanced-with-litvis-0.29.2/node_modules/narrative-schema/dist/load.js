"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.load = void 0;
const data_with_position_1 = require("data-with-position");
const lodash_1 = __importDefault(require("lodash"));
const narrative_schema_common_1 = require("narrative-schema-common");
const narrative_schema_label_1 = require("narrative-schema-label");
const narrative_schema_rule_1 = require("narrative-schema-rule");
const narrative_schema_styling_1 = require("narrative-schema-styling");
const path_1 = require("path");
const to_vfile_1 = require("to-vfile");
const vfile_1 = __importDefault(require("vfile"));
const traceParents_1 = require("./traceParents");
const resolveNarrativeSchemaPath = (path, file) => __awaiter(void 0, void 0, void 0, function* () {
    let result = path_1.resolve(file.dirname || "", path);
    if (!lodash_1.default.endsWith(result.toLowerCase(), ".yml") &&
        !lodash_1.default.endsWith(result.toLowerCase(), ".yaml")) {
        result += ".yml";
    }
    return result;
});
exports.load = (dependenciesWithPosition, parents, filesInMemory, schemasAlreadyLoaded) => __awaiter(void 0, void 0, void 0, function* () {
    const kind = data_with_position_1.getKind(dependenciesWithPosition);
    if (kind === "null" || kind === "undefined") {
        return [];
    }
    if (kind !== "array") {
        if (parents[0]) {
            parents[0].message(`Expected the list of dependent schema narratives to be array, ${kind} given${traceParents_1.traceParents(parents)}`, data_with_position_1.getPosition(dependenciesWithPosition), "narrative-schema:load");
        }
    }
    const result = [];
    for (const pathWithPosition of dependenciesWithPosition) {
        const pathPosition = data_with_position_1.getPosition(pathWithPosition);
        const resolvedPath = yield resolveNarrativeSchemaPath(data_with_position_1.getValue(pathWithPosition), parents[0]);
        // silently skip narrative schema loading if already done so
        // this is not an issue; schema dependency graph does not have to ve acyclic
        if (lodash_1.default.find(schemasAlreadyLoaded, (schema) => schema.path === resolvedPath)) {
            continue;
        }
        let narrativeSchema;
        // load narrative schema file
        try {
            const fileInMemory = lodash_1.default.find(filesInMemory, (f) => f.path === resolvedPath);
            // TODO Improve type casting
            narrativeSchema = (fileInMemory
                ? vfile_1.default(fileInMemory)
                : yield to_vfile_1.read(resolvedPath, "utf8"));
            narrativeSchema.data = {
                labels: [],
                rules: [],
                styling: [],
            };
        }
        catch (e) {
            parents[0].message(`Unable to load narrative schema dependency ${pathWithPosition}${traceParents_1.traceParents(parents)}. Does file ${resolvedPath} exist?`, pathPosition, "narrative-schema:load");
            continue;
        }
        result.push(narrativeSchema);
        // parse yaml
        let dataWithPosition;
        try {
            dataWithPosition = data_with_position_1.fromYaml(narrativeSchema.contents.toString());
        }
        catch (e) {
            try {
                narrativeSchema.fail(`Unable to parse schema ${traceParents_1.traceParents(parents)}`, undefined, "narrative-schema:load");
            }
            catch (_a) {
                // noop, just preventing Error throwing
            }
            continue;
        }
        // ensure the YAML is an object
        const dataKind = data_with_position_1.getKind(dataWithPosition);
        if (dataKind !== "object") {
            try {
                narrativeSchema.fail(`Expected to find an object with keys, ${dataKind} found${traceParents_1.traceParents(parents)}`, undefined, "narrative-schema:content");
            }
            catch (e) {
                // noop, just preventing Error throwing
            }
            continue;
        }
        // load dependencies
        result.push(...(yield exports.load(dataWithPosition.dependencies, [narrativeSchema, ...parents], filesInMemory, [...schemasAlreadyLoaded, ...result])));
        // extract data
        narrativeSchema.data = {
            labels: narrative_schema_label_1.extractDefinitions(dataWithPosition, narrativeSchema),
            rules: narrative_schema_rule_1.extractDefinitions(dataWithPosition, narrativeSchema),
            styling: narrative_schema_styling_1.extractDefinitions(dataWithPosition, narrativeSchema),
        };
        // report unknown keys in schema
        narrative_schema_common_1.reportUnusedDataKeys(narrativeSchema, dataWithPosition, {
            labels: true,
            rules: true,
            styling: true,
            dependencies: true,
        }, []);
    }
    return result;
});
//# sourceMappingURL=load.js.map